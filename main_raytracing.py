##################################################
## Discripition
## This program calculates gravity wave paths and instability points.
## It is translated from the IDL code presented in Kogure et al. (2018; 2020; 2023). 
## This code is developted in Python 3.8.19
##################################################
## Terms and Conditions of Use  
## This program is free to use for academic, non-commercial purposes. 
## Modification of the code is not recommended; any moddifications are made at your own risk. 
## If used in publications, you must cite the specific referecences (see the following reference).
## We strongly encourage users to contact us for discussion before using the result of this software in publications, 
## to prevent misuse or misinterpretation of the output.
## The developers and their affiliated organizations are not responsible for any damages arising from use of the software.
## Reference
#### Raytracing theory
#### Marks, C. J., and S. D. Eckermann, 1995: A Three-Dimensional Nonhydrostatic Ray-Tracing Model for Gravity Waves: Formulation and Preliminary Results for the Middle Atmosphere. J. Atmos. Sci., 52, 1959–1984, https://doi.org/10.1175/1520-0469(1995)052<1959:ATDNRT>2.0.CO;2.
#### Growth rate of amplitudes
#### Geller, M. A., & Gong, J. (2010). Gravity wave kinetic, potential, and vertical fluctuation energies as indicators of different frequency gravity waves. Journal of Geophysical Research, 115, D11111. https://doi.org/10.1029/2009JD012266
#### The original IDL program for the raytracing part
#### Kogure, M., Nakamura, T., Ejiri, M. K., Nishiyama, T., Tomikawa, Y., & Tsutsumi, M. (2018). Effects of horizontal wind structure on a gravity wave event in the middle atmosphere over Syowa (69°S, 40°E), the Antarctic. Geophysical Research Letters, 45, 5151–5157. https://doi.org/10.1029/2018GL078264
#### The original IDL program for Growth rate of amplitudes
#### Kogure, M., Yue, J., Nakamura, T., Hoffmann, L., Vadas, S. L., Tomikawa, Y., et al. (2020). First direct observational evidence for secondary gravity waves generated by mountain waves over the Andes. Geophysical Research Letters, 47, e2020GL088845. https://doi.org/10.1029/2020GL088845
#### Kogure, M., Nakamura, T., Murphy, D. J., Taylor, M. J., Zhao, Y., Pautet, P.-D., et al. (2023). Characteristics of gravity wave horizontal phase velocity spectra in the mesosphere over the Antarctic stations, Syowa and Davis. Journal of Geophysical Research: Atmospheres, 128, e2022JD037751. https://doi.org/10.1029/2022JD037751
##################################################
## Author: Masaru Kogure
## Version: 3.0.1
## Email: masarukogure@yonsei.ac.kr
## Date: Last Update: 2025/06/02
##################################################

from random import weibullvariate
import numpy as np
from derivation import derivation
from meteo_para_v2 import meteo_para
from lunge_kutta4 import lunge_kutta4
from kernel_box import kernel_box
from scipy import signal
from netCDF4 import Dataset
import netCDF4 as nc
import matplotlib.pyplot as plt
import glob
from lunge_kutta4 import lunge_kutta4


date = "20210812"
dt = 60.
her = 17.
mn = 0.
ihh = ((np.int32(date[6::])) - 1) + (np.int32(her) - 1)
gome = []

#----------------read data----------------
i_date = 0
filename = "/RAID0/home/kogure/data/ERA5/physics/ERA5_"+ date[::6] + ".nc"#test
figuresave = '/RAID0/home/kogure/figure/ERA5/heavy_rain_2021/'
nd = filename.find('2021')
year = date[0:4]
mm = date[4:6]
dd = date[6:8]
time1 = her + np.arange(7)
#----------------para---------------------------
global const, O2, r, dt7200, dt3600, dt_2, g0
const = 29.26 # m/K
O2 = 0.00014584231#7.2921159 * 1e-5 * 2 #rad/s
r = 6.3781 * 1.e6 #[m] Mean radius of the earth
dt3600 =  dt/3600.
dt_2 = dt  * 0.5
g0 = 9.80665 #[m/s^2]
#----------------para---------------------------
variname = ['T', 'U', 'V', 'W', 'Z']
#--------read JAWARA data--------------------------
filenameJ = sorted(glob.glob("/home/masarukogure/masarukogure/data/JAWARA/" + year + "/T" + year[2:5] + mm + "*" ))
ncfileJ = Dataset(filenameJ[0])
lat = np.squeeze(np.array(ncfileJ.variables['latitude'][:]))
lon = np.squeeze(np.array(ncfileJ.variables['longitude'][:]))
#lonJ[lonJ > 180] = lonJ[lonJ > 180] - 360 
press = np.squeeze(np.array(ncfileJ.variables['level']))[0:-1] * 1.e2
t = np.squeeze(np.array(ncfileJ.variables["t"][ihh:ihh+len(time1), 0:-1, :, :]))
ncfileJ.close()
filenameJ = sorted(glob.glob("/home/masarukogure/masarukogure/data/JAWARA/" + year + "/U" + year[2:5] + mm + "*" ))
ncfileJ = Dataset(filenameJ[0])
u = np.squeeze(np.array(ncfileJ.variables["u"][ihh:ihh+len(time1), 0:-1, :, :]))
ncfileJ.close()
filenameJ = sorted(glob.glob("/home/masarukogure/masarukogure/data/JAWARA/" + year + "/V" + year[2:5] + mm + "*" ))
ncfileJ = Dataset(filenameJ[0])
v = np.squeeze(np.array(ncfileJ.variables["v"][ihh:ihh+len(time1), 0:-1,  :, :]))
filenameJ = sorted(glob.glob("/home/masarukogure/masarukogure/data/JAWARA/" + year + "/W" + year[2:5] + mm + "*" ))
ncfileJ = Dataset(filenameJ[0])
w = np.squeeze(np.array(ncfileJ.variables["w"][ihh:ihh+len(time1), 0:-1,  :, :]))
filenameJ = sorted(glob.glob("/home/masarukogure/masarukogure/data/JAWARA/" + year + "/Z" + year[2:5] + mm + "*" ))
ncfileJ = Dataset(filenameJ[0])
z = np.squeeze(np.array(ncfileJ.variables["z"][ihh:ihh+len(time1), 0:-1, :, :]))
ncfileJ.close()
ncfileJ = Dataset(filenameJ[0])
ncfileJ.close()
#--------read JAWARA data--------------------------
press = np.transpose(np.tile(press, (1,1,1,1)), (0,3,1,2)) 
PT = meteo_para.poten_temp(t, press * 1.e-2)
NF = meteo_para.brunt_fre(z, PT, dim = 4)
rho = meteo_para.density(press, t)
wv = meteo_para.ver_wind(w, rho)
H = meteo_para.scale_h(t)
phi = lat/180 * np.pi
ram = lon/180 * np.pi
dlat = lat[-2] - lat[-1]
dlon = lon[1] - lon[0]
dram = (lon[1] - lon[0])/180 * np.pi * r
dphi = (lat[1] - lat[0])/180 * np.pi * r
#----------------read data----------------
dudx = u * 0
dvdx = v * 0
dudy = u * 0
dvdy = v * 0
NERA = t.shape
wc = kernel_box.cosine_roll(len(lat), 0.1)
figuresave = '/home/masarukogure/masarukogure/raytrance/'

for i_high in range(NERA[1]):
    for i_time in range(NERA[0]):
        for i_lat in range(NERA[2]):
            dram1 = dram * np.abs(np.cos(phi[i_lat]))
            
            dudx[i_time, i_high, i_lat,:] = derivation.fft_diff(u[i_time, i_high, i_lat,:], dram1, idel_filter=1/(2 * dphi))
            dvdx[i_time, i_high, i_lat,:] = derivation.fft_diff(v[i_time, i_high, i_lat,:], dram1, idel_filter=1/(2 * dphi))
        for i_lon in range(NERA[3]):
            dudy[i_time, i_high, :, i_lon] = derivation.fft_diff(u[i_time, i_high, :, i_lon] * wc, dphi)
            dvdy[i_time, i_high, :, i_lon] = derivation.fft_diff(v[i_time, i_high, :, i_lon] * wc, dphi)


kh_list = ["469", "285", "135", "185"] 
k_list = np.array([2 * np.pi * 0.0020576131687242765 * 1.e-3, 2 * np.pi * 0.003086419753086417 * 1.e-3, 2 * np.pi * 0.007201646090534979 * 1.e-3, 2 * np.pi * 0.0051440329218107065 * 1.e-3])
l_list = np.array([2 * np.pi * 0.0005527915975677203 * 1.e-3, 2 * np.pi * 0.0016583747927031475 * 1.e-3, 2 * np.pi * 0.0016583747927031518 * 1.e-3, 2 * np.pi * 0.0016583747927031518 * 1.e-3])

#lonMlist = [130.]
#latMlist = [33.0]
lonMlist = [127.5, 130., 132.5]
latMlist = [30, 31.5, 33.0,34.5]
pltnum = 12

        
for kh, k, l in zip(kh_list, k_list, l_list):
    inum = 0
    axs= []
    axs1 = []
    axs2 = []
    axs3 = []
    for lonM in lonMlist:
        lonMs = lonM
        for latM in latMlist:
            latMs = latM
            if (lonMs == lonMlist[0]) and (latMs == latMlist[0]) :
                legend1 = [str(lonMs)+' E, ' + str(latMs) + ' N' ]
            timeM = her + mn/60
            zM = 35 * 1e3
            m1 = -2*np.pi/(20 * 1e3)
            Tin = 5.
            lonM = lonMs
            latM = latMs
            lonM1 = lonM
            latM1 = latMs
            zM1 = zM
            kM = k
            lM = l
            k1 = kM
            l1 = lM
            timeM1 = timeM
            

            dudx1, dudy1, dvdx1, dvdy1, u1, v1, w1, NF1, H1 = lunge_kutta4.data_interpo(dudx, dvdx, dudy, dvdy, u, v, w, NF, H, lon, lat, time1, z, lonM, latM, timeM, zM, dlat, dlon)
            f = O2 * np.sin(latM/180*np.pi)
            ome = np.sqrt(meteo_para.cal_dis_ral( k1, l1, [], f, NF1, H1, m = m1))
            gome = ome + (u1 * k1 + v1 * l1)
            print(lonM, latM)

            i = 0
            uM = np.NAN
            vM = np.NAN
            wM = np.NAN
            NFM = np.NAN
            HM = np.NAN
            omeM = np.NAN
            dz = 0.1
            try:        
                while dz:
                    dy, dx, dz, dk, dl, u1, v1, w1, NF1, ome1, H1 = lunge_kutta4.main_lunge(dudx, dvdx, dudy, dvdy, u, v, wv, NF, H, gome, k1, l1, lon, lat, time1, z, lonM1, latM1, timeM1, zM1, phi, ram, dt, dlat, dlon)
                    lonM1 = lonM1 + dx
                    latM1 = latM1 + dy
                    zM1 = zM1 + dz 
                    k1 = k1 + dk
                    l1 = l1 + dl
                    timeM1 = timeM1 + dt3600 
                    lonM = np.append(lonM, lonM1)
                    latM = np.append(latM, latM1)
                    zM = np.append(zM, zM1 )
                    kM = np.append(kM, k1)
                    lM = np.append(lM, l1)
                    timeM = np.append(timeM, timeM1)
                    if i == 0 :
                        uM = u1
                        vM = v1
                        wM = w1
                        NFM = NF1
                        HM = H1
                        omeM = ome1
                    else:
                        uM = np.append(uM, u1)
                        vM = np.append(vM, v1)
                        wM = np.append(wM, w1)
                        NFM = np.append(NFM, NF1)
                        HM = np.append(HM, H1)
                        omeM = np.append(omeM, ome1)        
                    i = i + 1
            except:
                N_full, Ri, mM = lunge_kutta4.instability(Tin, NFM, uM, vM, zM, HM, latM, lonM, timeM, omeM, kM, lM, m1, rho, t, z, dlat, dlon, time1, lat, lon )
                sigma = np.abs(np.gradient(mM, zM[0:-1])/(mM**2))
                op = np.where(Ri <= 0.25)[0]
                if op.size > 0:
                    op_min = op.min()
                ##plot or save here
                
                
                ##plot or save here
                inum += 1
                print('end')
print('end')
                